\item \textbf{{[}JPJC/PRELIM/9569/2020/P1/Q5{]} }

The stack is a first in last out data structure where the items are
inserted to and deleted from the top of the stack. The items of the
stack are globally stored in a fixed length array \texttt{S} of size
20. A stack pointer \texttt{sp} points to the top item in the stack,
and is initialised to 0. The three basic methods of the stack are:
\begin{itemize}
\item \texttt{PUSH(X) //inserts X as new item on the top of STACK S }
\item \texttt{POP() ~~//removes and returns item at the top of STACK S. }
\item \texttt{PEEK() ~//returns value of the item on top of STACK S without
removing it. }
\end{itemize}
\begin{enumerate}
\item Write the pseudocode for the algorithms \texttt{PUSH(X)}, \texttt{POP()},
and \texttt{PEEK()}.\hfill{}{[}5{]}
\end{enumerate}
The precedence order of the operators from highest to lowest is as
follows: 
\begin{enumerate}
\item[1.]  Parenthesis 
\item[2.] \texttt{ '\textasciicircum ' }
\item[3.]  \texttt{'{*}'} or \texttt{'/'} with equivalent level of priority 
\item[4.] \texttt{ '+'} or \texttt{'-'} with equivalent level of priority
\end{enumerate}
The pseudocode below shows a stack-based function \texttt{InfixToPostfix}
that converts and returns an input expression represented in infix
notation to its postfix form.

\noindent %
\noindent\begin{minipage}[t]{1\columnwidth}%
\texttt{FUNCTION InfixToPostfix(infix: STRING) RETURNS postfix }

\texttt{\qquad{}Scan through infix expression one token at a time
from leftmost. }

\texttt{\qquad{}Initialise empty STACK S }

\texttt{\qquad{}Initialise empty STRING postfix }

\texttt{FOR token read from infix item by item }

\texttt{\qquad{}\qquad{}CASE of token: }

\texttt{\qquad{}\qquad{}\qquad{}operand : postfix <- postfix +
token}

\texttt{\qquad{}\qquad{}\qquad{}'(' : PUSH(token) }

\texttt{\qquad{}\qquad{}\qquad{}')' : REPEAT postfix <- postfix
+ POP() UNTIL POP() = '(' operator:}

\texttt{\qquad{}\qquad{}\qquad{}\qquad{}WHILE S not empty }

\texttt{\qquad{}\qquad{}\qquad{}\qquad{}\qquad{}IF token = '('
THEN }

\texttt{\qquad{}\qquad{}\qquad{}\qquad{}\qquad{}\qquad{}BREAK }

\texttt{\qquad{}\qquad{}\qquad{}\qquad{}\qquad{}ENDIF }

\texttt{\qquad{}\qquad{}\qquad{}\qquad{}\qquad{}IF PEEK() is
higher or equal precedence than token THEN }

\texttt{\qquad{}\qquad{}\qquad{}\qquad{}\qquad{}\qquad{}postfix
<- postfix + POP() }

\texttt{\qquad{}\qquad{}\qquad{}\qquad{}\qquad{}ENDIF }

\texttt{\qquad{}\qquad{}\qquad{}\qquad{}ENDWHILE }

\texttt{\qquad{}\qquad{}\qquad{}\qquad{}PUSH(token) }

\texttt{\qquad{}\qquad{}END CASE }

\texttt{\qquad{}NEXT token }

\texttt{\qquad{}REPEAT }

\texttt{\qquad{}\qquad{}postfix <- postfix + POP() }

\texttt{\qquad{}UNTIL S is empty }

\texttt{\qquad{}RETURN postfix }

\texttt{ENDFUNCTION }%
\end{minipage}
\begin{enumerate}
\item[(b)]  Complete the trace table given below for \texttt{InfixToPostfix(\textquotedbl A/(B-C){*}D\textasciicircum E\textquotedbl )}. 
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline 
\texttt{token } & \texttt{Description } & \texttt{STRING postfix } & \texttt{Stack, S}\tabularnewline
\hline 
\hline 
\texttt{A} & \texttt{Appends to postfix } & \texttt{\textquotedbl A\textquotedbl{} } & \texttt{empty}\tabularnewline
\hline 
\texttt{/ } & \texttt{Push to S } & \texttt{\textquotedbl A\textquotedbl{} } & \texttt{/}\tabularnewline
\hline 
\texttt{( } & \texttt{Push to S } & \texttt{\textquotedbl A\textquotedbl{} } & \texttt{/,(}\tabularnewline
\hline 
\texttt{\dots{} } & \texttt{\dots \dots \dots \dots \dots{} } & \texttt{\dots \dots \dots \dots \dots{} } & \texttt{\dots \dots \dots \dots \dots{}}\tabularnewline
\hline 
\end{tabular}
\par\end{center}

\end{enumerate}
\hfill{}{[}4{]}
\begin{enumerate}
\item[(c)]  Show, with the aid of diagrams, how the computer uses a stack to
directly evaluate the value of the postfix expression \texttt{895-/12+{*}4-}.
\hfill{}{[}3{]}
\end{enumerate}