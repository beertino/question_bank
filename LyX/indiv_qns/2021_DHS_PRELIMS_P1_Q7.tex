\item \textbf{{[}DHS/PRELIM/9569/2021/P1/Q7{]} }

A divide and conquer approach is used by merge sort to successively
divide a list into half, forming two sublists, until each sublist
is of length 1. The sublists are then sorted and merged into larger
sublists until they are recombined into a single sorted list. An algorithm
for merge sort to perform an ascending sort is given below. It will
be used to sort large or small data sizes. 

\noindent %
\noindent\begin{minipage}[t]{1\columnwidth}%
\texttt{01 PROCEDURE mergesort(mergelist : ARRAY) }

\texttt{02}

\texttt{03 \qquad{}IF LENGTH(mergelist) > 1 THEN }

\texttt{04 }

\texttt{05 \qquad{}\qquad{}mid \textleftarrow{} LENGTH(mergelist)
DIV 2 }

\texttt{06 }

\texttt{07 \qquad{}\qquad{}FOR index \textleftarrow{} 0 TO (mid
- 1) }

\texttt{08 \qquad{}\qquad{}\qquad{}lefthalf{[}index{]} \textleftarrow{}
mergelist{[}index{]} }

\texttt{09 \qquad{}\qquad{}NEXT index}

\texttt{10}

\texttt{11 \qquad{}\qquad{}right\_len \textleftarrow{} LENGTH(mergelist)
- mid}

\texttt{12}

\texttt{13 \qquad{}\qquad{}FOR index \textleftarrow{} 0 TO (right\_len
- 1) }

\texttt{14 \qquad{}\qquad{}\qquad{}righthalf{[}index{]} \textleftarrow{}
mergelist{[}right\_len + index{]} }

\texttt{15 \qquad{}\qquad{}NEXT index }

\texttt{16}

\texttt{17 \qquad{}\qquad{}mergesort(lefthalf) }

\texttt{18 \qquad{}\qquad{}mergesort(righthalf) }

\texttt{19}

\texttt{20 \qquad{}\qquad{}i \textleftarrow{} 0 }

\texttt{21 \qquad{}\qquad{}j \textleftarrow{} 0 }

\texttt{22 \qquad{}\qquad{}k \textleftarrow{} 0 }

\texttt{23 \qquad{}\qquad{}WHILE i < LENGTH(lefthalf) AND j < LENGTH(righthalf) }

\texttt{24 \qquad{}\qquad{}\qquad{}IF lefthalf{[}i{]} > righthalf{[}j{]}
THEN }

\texttt{25 \qquad{}\qquad{}\qquad{}\qquad{}mergelist{[}k{]} \textleftarrow{}
lefthalf{[}i{]}}

\texttt{26 \qquad{}\qquad{}\qquad{}\qquad{}i \textleftarrow{}
i + 1 }

\texttt{27 \qquad{}\qquad{}\qquad{}ELSE }

\texttt{28 \qquad{}\qquad{}\qquad{}\qquad{}mergelist{[}k{]} \textleftarrow{}
righthalf{[}j{]} }

\texttt{29 \qquad{}\qquad{}\qquad{}\qquad{}j \textleftarrow{}
j + 1 }

\texttt{30 \qquad{}\qquad{}\qquad{}ENDIF }

\texttt{31 \qquad{}\qquad{}\qquad{}k \textleftarrow{} k + 1}

\texttt{32 \qquad{}\qquad{}ENDWHILE }

\texttt{33}

\texttt{34 \qquad{}\qquad{}WHILE i < LENGTH(lefthalf) }

\texttt{35 \qquad{}\qquad{}\qquad{}mergelist{[}k{]} \textleftarrow{}
lefthalf{[}i{]} }

\texttt{36 \qquad{}\qquad{}\qquad{}i \textleftarrow{} i + 1 }

\texttt{37 \qquad{}\qquad{}\qquad{}k \textleftarrow{} k + 1 }

\texttt{38 \qquad{}\qquad{}ENDWHILE }

\texttt{39}

\texttt{40 \qquad{}\qquad{}WHILE j < LENGTH(righthalf) }

\texttt{41 \qquad{}\qquad{}\qquad{}mergelist(k{]} \textleftarrow{}
righthalf{[}j{]} }

\texttt{42 \qquad{}\qquad{}\qquad{}j \textleftarrow{} j + 1 }

\texttt{43 \qquad{}\qquad{}\qquad{}k \textleftarrow{} k + 1 }

\texttt{44 \qquad{}\qquad{}ENDWHILE }

\texttt{45 \qquad{}ENDIF }

\texttt{46 ENDPROCEDURE }%
\end{minipage}
\begin{enumerate}
\item The following array of numbers is to be sorted using \texttt{mergesort}: 
\noindent \begin{center}
\texttt{mergelist = {[}2, 4, 2, 8, 2, 8, 9, 1, 3{]}} 
\par\end{center}

What are the first two lists to be merged? \hfill{}{[}1{]}
\item Explain what a logic error is, give the line number for the logic
error in the above code, and rewrite the line correctly. \hfill{}
{[}2{]}
\end{enumerate}
The procedure\texttt{ sorting\_proc} uses an optimised bubble sort
to sort an array\texttt{ input\_array} in an ascending order. It is
used within \texttt{modified\_mergesort} which is a modified version
of \texttt{mergesort}. 

\noindent %
\noindent\begin{minipage}[t]{1\columnwidth}%
\texttt{01 PROCEDURE sorting\_proc(input\_array : ARRAY) }

\texttt{02}

\texttt{03 \qquad{}length \textleftarrow{} LENGTH(input\_array) }

\texttt{04}

\texttt{05 \qquad{}REPEAT }

\texttt{06 \qquad{}\qquad{}swapped \textleftarrow{} FALSE }

\texttt{07}

\texttt{08 \qquad{}\qquad{}FOR curr\_elem\_index \textleftarrow{}
1 to length \textendash{} 1 }

\texttt{09}

\texttt{10 \qquad{}\qquad{}\qquad{}IF input\_array {[}curr\_elem\_index
- 1{]} > input\_array {[}curr\_elem\_index{]} THEN }

\texttt{11 \qquad{}\qquad{}\qquad{}\qquad{}SWAP (input\_array
{[}curr\_elem\_index - 1{]}, input\_array {[}curr\_elem\_index{]}) }

\texttt{12 \qquad{}\qquad{}\qquad{}\qquad{}swapped \textleftarrow{}
TRUE }

\texttt{13 \qquad{}\qquad{}\qquad{}ENDIF}

\texttt{14 }

\texttt{15 \qquad{}\qquad{}ENDFOR}

\texttt{16}

\texttt{17 \qquad{}\qquad{}length \textleftarrow{} length \textendash{}
1 }

\texttt{18 }

\texttt{19 \qquad{}UNTIL NOT swapped }

\texttt{20}

\texttt{21 ENDPROCEDURE }%
\end{minipage}

\noindent %
\noindent\begin{minipage}[t]{1\columnwidth}%
\texttt{01 PROCEDURE modified\_mergesort(mergelist : ARRAY) }

\texttt{02 }

\texttt{03 \qquad{}IF LENGTH(mergelist) > 1 THEN }

\texttt{04 }

\texttt{05 \qquad{}\qquad{}IF LENGTH(mergelist) < 5 THEN }

\texttt{06 \qquad{}\qquad{}\qquad{}sorting\_proc(mergelist) }

\texttt{07 \qquad{}\qquad{}\qquad{}RETURN}

\texttt{08 }

\texttt{09 \qquad{}\qquad{}ELSE}

\texttt{10}

\texttt{11 \qquad{}\qquad{}\qquad{}mid \textleftarrow{} LENGTH(mergelist)
DIV 2 }

\texttt{12 }

\texttt{13 \qquad{}\qquad{}\qquad{}FOR index \textleftarrow{} 0
TO (mid - 1) }

\texttt{14 \qquad{}\qquad{}\qquad{}\qquad{}lefthalf{[}index{]}
\textleftarrow{} mergelist{[}index{]} }

\texttt{15 \qquad{}\qquad{}\qquad{}NEXT index}

\texttt{16}

\texttt{17 \qquad{}\qquad{}\qquad{}right\_len \textleftarrow{}
LENGTH(mergelist) - mid }

\texttt{18}

\texttt{19 \qquad{}\qquad{}\qquad{}FOR index \textleftarrow{} 0
TO (right\_len - 1) }

\texttt{20 \qquad{}\qquad{}\qquad{}\qquad{}righthalf{[}index{]}
\textleftarrow{} mergelist{[}right\_len + index{]} }

\texttt{21 \qquad{}\qquad{}\qquad{}NEXT index }

\texttt{22}

\texttt{23 \qquad{}\qquad{}\qquad{}mergesort(lefthalf) }

\texttt{24 \qquad{}\qquad{}\qquad{}mergesort(righthalf) }

\texttt{25}

\texttt{26 \qquad{}\qquad{}\qquad{}i \textleftarrow{} 0 }

\texttt{27 \qquad{}\qquad{}\qquad{}j \textleftarrow{} 0 }

\texttt{28 \qquad{}\qquad{}\qquad{}k \textleftarrow{} 0 }

\texttt{29 \qquad{}\qquad{}\qquad{}WHILE i < LENGTH(lefthalf) AND
j < LENGTH(righthalf) }

\texttt{30 \qquad{}\qquad{}\qquad{}\qquad{}IF lefthalf{[}i{]}
> righthalf{[}j{]} THEN }

\texttt{31 \qquad{}\qquad{}\qquad{}\qquad{}\qquad{}mergelist{[}k{]}
\textleftarrow{} lefthalf{[}i{]} }

\texttt{32 \qquad{}\qquad{}\qquad{}\qquad{}\qquad{}i \textleftarrow{}
i + 1 }

\texttt{33 \qquad{}\qquad{}\qquad{}\qquad{}ELSE }

\texttt{34 \qquad{}\qquad{}\qquad{}\qquad{}\qquad{}mergelist{[}k{]}
\textleftarrow{} righthalf{[}j{]}}

\texttt{35 \qquad{}\qquad{}\qquad{}\qquad{}\qquad{}j \textleftarrow{}
j + 1 }

\texttt{36 \qquad{}\qquad{}\qquad{}\qquad{}ENDIF }

\texttt{37 \qquad{}\qquad{}\qquad{}\qquad{}k \textleftarrow{}
k + 1 }

\texttt{38 \qquad{}\qquad{}\qquad{}ENDWHILE }

\texttt{39 }

\texttt{40 \qquad{}\qquad{}\qquad{}WHILE i < LENGTH(lefthalf) }

\texttt{41 \qquad{}\qquad{}\qquad{}\qquad{}mergelist{[}k{]} \textleftarrow{}
lefthalf{[}i{]} }

\texttt{42 \qquad{}\qquad{}\qquad{}\qquad{}i \textleftarrow{}
i + 1 }

\texttt{43 \qquad{}\qquad{}\qquad{}\qquad{}k \textleftarrow{}
k + 1}

\texttt{44 \qquad{}\qquad{}\qquad{}ENDWHILE}

\texttt{45 }

\texttt{46 \qquad{}\qquad{}\qquad{}WHILE j < LENGTH(righthalf)}

\texttt{47 \qquad{}\qquad{}\qquad{}\qquad{}mergelist{[}k{]} \textleftarrow{}
righthalf{[}j{]} }

\texttt{48 \qquad{}\qquad{}\qquad{}\qquad{}j \textleftarrow{}
j + 1 }

\texttt{49 \qquad{}\qquad{}\qquad{}\qquad{}k \textleftarrow{}
k + 1 }

\texttt{50 \qquad{}\qquad{}\qquad{}ENDWHILE }

\texttt{51 \qquad{}\qquad{}ENDIF }

\texttt{52 \qquad{}ENDIF }

\texttt{53 ENDPROCEDURE}%
\end{minipage}
\begin{enumerate}
\item[(c)]  Would the above modification of mergesort improve the algorithm\textquoteright s
overall efficiency? Support your answer with a description on how
and explanation on why its efficiency is affected. \hfill{} {[}4{]}
\end{enumerate}
The procedure \texttt{insertionSort} is an algorithm which uses insertion
sort. 

\noindent %
\noindent\begin{minipage}[t]{1\columnwidth}%
\texttt{01 PROCEDURE insertionSort(input\_array: ARRAY) }

\texttt{02 }

\texttt{03 \qquad{}current\_elem\_index \textleftarrow{} 0 }

\texttt{04 }

\texttt{05 \qquad{}REPEAT }

\texttt{06 \qquad{}\qquad{}current\_elem\_index \textleftarrow{}
current\_elem\_index + 1 }

\texttt{07 \qquad{}\qquad{}compared\_item\_index \textleftarrow{}
-1 }

\texttt{08 \qquad{}\qquad{}swapped \textleftarrow{} FALSE }

\texttt{09 }

\texttt{10 \qquad{}\qquad{}REPEAT }

\texttt{11 \qquad{}\qquad{}\qquad{}compared\_item\_index \textleftarrow{}
compared\_item\_index + 1 }

\texttt{12 }

\texttt{13 \qquad{}\qquad{}\qquad{}IF input\_array{[}current\_elem\_index{]}
< input\_array{[}compared\_item\_index{]} THEN }

\texttt{14 }

\texttt{15 \qquad{}\qquad{}\qquad{}\qquad{}temp \textleftarrow{}
input\_array{[}current\_elem\_index{]}}

\texttt{16 }

\texttt{17 \qquad{}\qquad{}\qquad{}\qquad{}the value of each element
of input\_array from compared\_item\_index to (current\_elem\_index
\textendash{} 1) is sequentially assigned to each element of input\_array
from (compared\_item\_index + 1) to current\_elem\_index}

\texttt{18 }

\texttt{19 \qquad{}\qquad{}\qquad{}\qquad{}input\_array{[}compared\_item\_index{]}
\textleftarrow{} temp }

\texttt{20 }

\texttt{21 \qquad{}\qquad{}\qquad{}\qquad{}swapped \textleftarrow{}
TRUE }

\texttt{22 \qquad{}\qquad{}\qquad{}ENDIF }

\texttt{23 }

\texttt{24 \qquad{}\qquad{}UNTIL swapped \textleftarrow{} TRUE }

\texttt{25 }

\texttt{26 \qquad{}UNTIL current\_elem\_index = LENGTH(input\_array)
- 1 }

\texttt{27 }

\texttt{28 ENDPROCEDURE }%
\end{minipage}
\begin{enumerate}
\item[(d)]  Modify \texttt{insertionSort} and \texttt{sorting\_proc} to count
and store the number of comparisons made in a variable named \texttt{comparisons}.
Instead of copying all the pseudocode statements, state the line number(s)
you want to modify or insert any pseudocode at, followed by the pseudocode
statement(s) to be added/modified. \hfill{}{[}3{]}
\item[(e)]  Trace the modified algorithms \texttt{insertionSort} and \texttt{sorting\_proc}
for the array \texttt{{[}5, 2, 3, 4{]}} showing the value of all variables
for each step by completing the following tables. 

Trace table for \texttt{insertionSort}: 

\texttt{}%
\begin{tabular}{|c|c|c|c|c|}
\hline 
\texttt{current\_elem \_index } & \texttt{compared\_item\_index } & \texttt{comparisons} & \texttt{input\_array} & \texttt{swapped}\tabularnewline
\hline 
\texttt{1} & \texttt{0} & \texttt{1} & \texttt{{[}2,5,3,4{]}} & \texttt{TRUE}\tabularnewline
\hline 
\texttt{2} & \texttt{0} & \texttt{2} & \texttt{{[}2,5,3,4{]}} & \texttt{FALSE}\tabularnewline
\hline 
... & ... & ... & ... & \tabularnewline
\hline 
\end{tabular}

Trace table for \texttt{sorting\_proc}: 

\texttt{}%
\begin{tabular}{|c|c|c|c|c|}
\hline 
\texttt{current\_elem \_index} & \texttt{compared\_item\_index} & \texttt{input\_array} & \texttt{arr\_length} & \texttt{swapped}\tabularnewline
\hline 
\texttt{1} & \texttt{1} & \texttt{{[}2,5,3,4{]}} & \texttt{4} & \texttt{TRUE}\tabularnewline
\hline 
\texttt{2} & 2 & \texttt{{[}2,5,3,4{]}} & \texttt{4} & \texttt{FALSE}\tabularnewline
\hline 
... & ... & \texttt{...} & ... & \texttt{...}\tabularnewline
\hline 
\end{tabular} 

\hfill{}{[}7{]}
\item[(f)]  In the context of \texttt{mergesort}, suggest scenario(s) where
using the current optimised bubble sort algorithm for \texttt{sorting\_proc}
would be better than using the \texttt{insertionSort} algorithm above.
Support your answer by designing 3 test cases (normal and boundary)
and comparing the number of \texttt{comparisons} made by each algorithm
for each test case. Display your output. \hfill{} {[}7{]}
\end{enumerate}