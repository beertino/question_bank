\item \textbf{{[}JJC/PRELIM/9597/2018/P2/Q6{]} }

The following pseudo-code contains an algorithm called \texttt{Merge}
that is called by the \texttt{MergeSort} algorithm. 

\noindent %
\noindent\begin{minipage}[t]{1\columnwidth}%
\texttt{FUNCTION MergeSort(L, S, E)}

\texttt{\qquad{}IF S < E THEN }

\texttt{\qquad{}\qquad{}M <- (S + E) DIV 2 }

\texttt{\qquad{}\qquad{}L1 <- MergeSort(L, S, M) }

\texttt{\qquad{}\qquad{}L2 <- MergeSort(L, M + 1, E) }

\texttt{\qquad{}\qquad{}RETURN Merge(L1, L2)}

\texttt{\qquad{}ELSE }

\texttt{\qquad{}\qquad{}RETURN Append({[}{]}, L{[}S{]}) }

\texttt{\qquad{}ENDIF}

\texttt{ENDFUNCTION}

\bigskip{}

\texttt{FUNCTION Merge(L1, L2) }

\texttt{\qquad{}L3 <- {[}{]} }

\texttt{\qquad{}WHILE Len(L1) > 0 AND LEN(L2) > 0}

\texttt{\qquad{}\qquad{}IF L1{[}1{]} < L2{[}1{]} THEN }

\texttt{\qquad{}\qquad{}\qquad{}L3 <- Append(L2{[}1{]}, L3) }

\texttt{\qquad{}\qquad{}\qquad{}L2 <- RemoveFirstItem(L2) }

\texttt{\qquad{}\qquad{}ELSE }

\texttt{\qquad{}\qquad{}\qquad{}L3 <- Append(L1{[}1{]}, L3) }

\texttt{\qquad{}\qquad{}\qquad{}L1 <- RemoveFirstItem(L1) }

\texttt{\qquad{}\qquad{}ENDIF}

\texttt{\qquad{}ENDWHILE}

\texttt{\qquad{}WHILE Len(L1) > 0}

\texttt{\qquad{}\qquad{}L3 <- Append(L1{[}1{]}, L3) }

\texttt{\qquad{}\qquad{}L1 <- RemoveFirstItem(L1) }

\texttt{\qquad{}ENDWHILE }

\texttt{\qquad{}WHILE Len(L2) > 0 }

\texttt{\qquad{}\qquad{}L3 <- Append(L2{[}1{]}, L3)}

\texttt{\qquad{}\qquad{}L2 <- RemoveFirstItem(L2) }

\texttt{\qquad{}ENDWHILE }

\texttt{\qquad{}RETURN L3}

\texttt{ENDFUNCTION} %
\end{minipage}

The \texttt{RemoveFirstItem} function takes a list and returns a list
that contains all the items in the original list except the first
one. For example, if \texttt{Names} is the list {[}\textquotedbl\texttt{Gemma}\textquotedbl ,
\textquotedbl\texttt{Richard}\textquotedbl , \textquotedbl\texttt{Georgina}\textquotedbl ,
\textquotedbl\texttt{Margaret}\textquotedbl{]} then the function
call \texttt{RemoveFirstItem(Names)} will return the list {[}\textquotedbl\texttt{Richard}\textquotedbl ,
\textquotedbl\texttt{Georgina}\textquotedbl , \textquotedbl\texttt{Margaret}\textquotedbl{]}. 

The \texttt{Len} function takes a list and returns the number of items
that are in the list. For example, if \texttt{Names} is the list {[}\textquotedbl\texttt{Gemma}\textquotedbl ,
\textquotedbl\texttt{Richard}\textquotedbl , \textquotedbl\texttt{Georgina}\textquotedbl ,
\textquotedbl\texttt{Margaret}\textquotedbl{]} then the function
call \texttt{Len(Names)} will return the value of 4. 

The \texttt{Append} function takes an item and a list and returns
a list that has all the items from the original list followed by the
item. For example, if \texttt{Names} is the list {[}\textquotedbl\texttt{Gemma}\textquotedbl ,
\textquotedbl\texttt{Richard}\textquotedbl , \textquotedbl\texttt{Georgina}\textquotedbl ,
\textquotedbl\texttt{Margaret}\textquotedbl{]} then the function
call\texttt{ Append(\textquotedbl Matt\textquotedbl , Names)} will
return the list {[}\textquotedbl\texttt{Gemma}\textquotedbl , \textquotedbl\texttt{Richard}\textquotedbl ,
\textquotedbl\texttt{Georgina}\textquotedbl , \textquotedbl\texttt{Margaret}\textquotedbl ,
\textquotedbl\texttt{Matt}\textquotedbl{]}.

The first item in the list has an index of 1. 
\begin{enumerate}
\item What is meant by a recursive subroutine? \hfill{}{[}1{]}
\item What is the base case for the subroutine \texttt{MergeSort}? \hfill{}
{[}1{]}
\item Complete the following table to show the result of tracing \texttt{MergeSort}
with the function call \texttt{MergeSort(ListToSort, 1, 5)}. \hfill{}{[}4{]}
\end{enumerate}
\texttt{ListToSort} is the list \texttt{{[}6, 3, 4, 8, 5{]}}. The
first six rows and the call number column have been completed for
you. 
\noindent \begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline 
\textbf{Call number} & \textbf{S} & \textbf{E} & \textbf{M} & \textbf{List returned}\tabularnewline
\hline 
1 & 1 & 5 & 3 & \tabularnewline
\hline 
2 & 1 & 3 & 2 & \tabularnewline
\hline 
3 & 1 & 2 & 1 & \tabularnewline
\hline 
4 & 1 & 1 &  & {[}6{]}\tabularnewline
\hline 
3 & 1 & 2 & 1 & \tabularnewline
\hline 
5 & 2 & 2 &  & {[}3{]}\tabularnewline
\hline 
3 &  &  &  & \tabularnewline
\hline 
2 &  &  &  & \tabularnewline
\hline 
6 &  &  &  & \tabularnewline
\hline 
2 &  &  &  & \tabularnewline
\hline 
1 &  &  &  & \tabularnewline
\hline 
7 &  &  &  & \tabularnewline
\hline 
8 &  &  &  & \tabularnewline
\hline 
7 &  &  &  & \tabularnewline
\hline 
9 &  &  &  & \tabularnewline
\hline 
7 &  &  &  & \tabularnewline
\hline 
1 &  &  &  & \tabularnewline
\hline 
\end{tabular}
\par\end{center}
\begin{enumerate}
\item[(d) ] What is the time complexity for the MergeSort algorithm? \hfill{}
{[}1{]}
\end{enumerate}