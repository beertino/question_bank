\item \textbf{{[}HCI/PRELIM/9569/2020/P1/Q6{]} }
\begin{enumerate}
\item State \textbf{two} key characteristics of a recursive function, and
when is it suitable to be used. {[}3{]}
\item The procedure \texttt{MoveTower(n,i,j)} shown below simulates the
movement of moving \texttt{n} discs from peg \texttt{i} to peg \texttt{j}.

\noindent %
\noindent\begin{minipage}[t]{1\columnwidth}%
\texttt{PROCEDURE MoveTower(n, i, j) }

\texttt{\qquad{}IF n = 1 OUTPUT (\textquotedbl Move disc from peg\textquotedbl ,
i, \textquotedbl to peg\textquotedbl , j) }

\texttt{\qquad{}ELSE }

\texttt{\qquad{}\qquad{}MoveTower(n-1, i, 6-i-j) }

\texttt{\qquad{}\qquad{}OUTPUT (\textquotedbl Move disc from peg\textquotedbl ,
i, \textquotedbl to peg\textquotedbl , j) }

\texttt{\qquad{}\qquad{}MoveTower(n-1, 6-i-j, j) }

\texttt{\qquad{}ENDIF}

\texttt{ENDPROCEDURE}%
\end{minipage}
\begin{enumerate}
\item Dry-run the procedure and show the output that is produced when the
task is to move 3 discs from peg 1 to peg 3. \hfill{}{[}3{]}
\item Assuming a stack is used for passing parameters to the procedure,
show also the contents of the stack, excluding the return address,
after each of the first \textbf{five} procedure calls. \hfill{} {[}3{]}
\end{enumerate}
\item If a procedure is to be able to call itself recursively, it is usual
for the values of any variables used in the procedure to be held in
a stack rather than in fixed storage. Why is this? \hfill{}{[}1{]}
\end{enumerate}