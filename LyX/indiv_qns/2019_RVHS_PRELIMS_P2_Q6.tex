\item \textbf{{[}RVHS/PRELIM/9597/2019/P2/Q6{]} }

A sort procedure is implemented in Python is follow.

\noindent %
\noindent\begin{minipage}[t]{1\columnwidth}%
\texttt{def sort(sort\_lst, unsort\_lst):}

\texttt{\qquad{}if len(unsort\_lst) > 0: }

\texttt{\qquad{}\qquad{}item = unsort\_lst{[}0{]} }

\texttt{\qquad{}\qquad{}i = 0 }

\texttt{\qquad{}\qquad{}while i < len(sort\_lst) and item < sort\_lst{[}i{]}: }

\texttt{\qquad{}\qquad{}\qquad{}i += 1 }

\texttt{\qquad{}\qquad{}return sort(sort\_lst{[}:i{]}+{[}item,{]}+sort\_lst{[}i:{]},
unsort\_lst{[}1:{]})}

\texttt{\qquad{}else:}

\texttt{\qquad{}\qquad{}return sort\_lst}%
\end{minipage}
\begin{enumerate}
\item State the name of the above sorting algorithm. \hfill{}{[}1{]}
\item The below statement is executed.

\texttt{>\textcompwordmark >\textcompwordmark > sort({[}{]}, {[}9,1,8,2,3,7,5{]})}

Using the table below, trace the items in \texttt{sort\_lst} and \texttt{unsort\_lst}
in each recursive call.
\noindent \begin{center}
\begin{tabular}{|c|c|c|}
\hline 
\texttt{\textbf{\#}} & \texttt{\textbf{sort\_lst}} & \texttt{\textbf{unsort\_lst}}\tabularnewline
\hline 
\texttt{1} & \texttt{{[}{]}} & \texttt{{[}9,1,8,2,3,7,5{]}}\tabularnewline
\hline 
\texttt{2} &  & \tabularnewline
\hline 
\texttt{3} &  & \tabularnewline
\hline 
\texttt{4} &  & \tabularnewline
\hline 
\texttt{5} &  & \tabularnewline
\hline 
\texttt{6} &  & \tabularnewline
\hline 
\texttt{7} &  & \tabularnewline
\hline 
\texttt{8} &  & \tabularnewline
\hline 
\end{tabular}
\par\end{center}

\hfill{}{[}3{]}
\item State the time complexity of the sort procedure above. \hfill{}{[}1{]}
\end{enumerate}
\quad{} A sleepy teacher implemented an inefficient binary search
function as follow. The function is supposed to return True if target
is found in the list inc\_sort\_lst and False otherwise.

\noindent %
\noindent\begin{minipage}[t]{1\columnwidth}%
\texttt{01 def binSearch(target, inc\_sort\_lst):}

\texttt{02 if len(inc\_sort\_lst) == 0: }

\texttt{03 \qquad{}return False}

\texttt{04 if len(inc\_sort\_lst) == 1: }

\texttt{05 \qquad{}return True }

\texttt{06 n = len(inc\_sort\_lst)}

\texttt{07 first\_half = inc\_sort\_lst{[}:n//2{]} }

\texttt{08 second\_half = inc\_sort\_lst{[}n//2:{]} }

\texttt{09 if target > first\_half{[}-1{]}: }

\texttt{10 \qquad{}return binSearch(target, second\_half) }

\texttt{11 else: }

\texttt{12 \qquad{}return binSearch(target, first\_half)}%
\end{minipage}
\begin{enumerate}
\item[(d)]  Explain the bug in his code with examples. \hfill{}{[}1{]}
\item[(e)]  Explain how you can correct the bug without changing the code from
line 06 onwards.\hfill{} {[}2{]}
\item[(f)]  Explain why the binary search performed is inefficient.\hfill{}
{[}2{]}
\end{enumerate}