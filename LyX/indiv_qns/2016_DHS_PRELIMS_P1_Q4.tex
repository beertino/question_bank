\item \textbf{{[}DHS/PRELIM/9597/2016/P1/Q4{]} }

A magic index in an array A is defined to be an index such that \texttt{A{[}i{]}
= i}. 

\subsection*{Task 4.1 }

Given a sorted array of distinct integers, write a brute force iterative
method \texttt{magic\_index(A)} to find a magic index if one exists.
If a magic index does not exist, return -1. 

\subsection*{Evidence 21: }

Function code for \texttt{magic\_index(A)} and relevant driver code.\hfill{}
{[}5{]}

\subsection*{Evidence 22: }

Screenshot of output.\hfill{} {[}2{]}

\subsection*{Task 4.2 }

Write an efficient recursive method \texttt{magic\_index\_duplicates(A)}
to find a magic index for an array containing non-distinct values.
If a magic index does not exist, return -1.

\subsection*{Evidence 23: }

Function code for \texttt{magic\_index\_duplicates(A)} and relevant
driver code. \hfill{} {[}6{]}

\subsection*{Evidence 24:}

Screenshot of output. \hfill{} {[}2{]}

A child is running up a staircase with n steps and can hop either
1, 2 or 3 steps at a time. 

\subsection*{Task 4.3 }

Write a brute force recursive method to count how many possible ways
the child can run up the stairs. 

\subsection*{Evidence 25: }

Function code and relevant driver code.\hfill{} {[}5{]}

\subsection*{Evidence 26: }

Screenshot of output.\hfill{} {[}2{]}

\subsection*{Task 4.4 }

Optimise your brute force recursive solution in Task 4.3 by eliminating
unnecessary recomputations.

\subsection*{Evidence 27: }

Function code and relevant driver code.\hfill{} {[}6{]}

\subsection*{Evidence 28:}

Screenshots showing annotated test cases. \hfill{} {[}2{]}