#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Binary search can only be used on Sorted array.
 On the other hand, linear search can also be used on unsorted array 
\end_layout

\begin_layout Itemize
Binary search has a time complexity of 
\begin_inset Formula $O\left(\log n\right)$
\end_inset

 when linear search is 
\begin_inset Formula $O\left(n\right)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Linear search is more appropriate here as it has 
\begin_inset Formula $O\left(n\right)$
\end_inset

 time complexity.
 If binary search is to be used here, we must first sort the array, which
 has 
\begin_inset Formula $O\left(n\log n\right)$
\end_inset

, on top of the 
\begin_inset Formula $O\left(\log n\right)$
\end_inset

 time complexity of the search itself.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family typewriter
FUNCTION LinearSearch(A: Array[1:N] OF INTEGER, k:INTEGER) RETURNS INTEGER
 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

val <- MAXINT 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

pos <- -1 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

FOR i <- 1 TO N: 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

IF A[i] > k and A[i] < val: 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

val <- L[i] 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

pos <- i 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

RETURN pos 
\end_layout

\begin_layout Plain Layout

\family typewriter
ENDFUNCTION 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Iterative version.
 Every recursive function pushes state data into the call stack memory,
 if the depth of the binary search exceeds the call stack memory, it will
 result in a run time stack overflow error.
 As there are no function calls and the all data state changes within a
 local function scope, iterative version is sufficient.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Source
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Directly Connected Neighbours
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Node(1)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
[Node(2), Node(3)]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Node(2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
[Node(4)]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Node(3)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
[Node(2)]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Node(4)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
[Node(3)]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Enumerate
The methods are:
\end_layout

\begin_deeper
\begin_layout Enumerate

\family typewriter
append (n: Object)
\family default
: 
\family typewriter
None
\family default
 // add object 
\family typewriter
n
\family default
 to the end of the 
\family typewriter
List
\end_layout

\begin_layout Enumerate

\family typewriter
getHead(): Object
\family default
 // returns the first object in the 
\family typewriter
List
\family default
, 
\family typewriter
None
\family default
 if empty 
\family typewriter
List
\end_layout

\begin_layout Enumerate

\family typewriter
getNext(n: Object): Object
\family default
 // returns the next object from the 
\family typewriter
List
\family default
 after 
\family typewriter
n
\family default
 , returns 
\family typewriter
None
\family default
 if 
\family typewriter
n
\family default
 is the last node in the 
\family typewriter
List
\family default
 
\end_layout

\end_deeper
\begin_layout Enumerate
Since the set of nodes in the graph do not not have duplicates, we can use
 a 
\family typewriter
Dictionary
\family default
 data structure.
 The keys in the Dictionary are the IDs of the nodes and its corresponding
 values are a 
\family typewriter
List
\family default
 of 
\family typewriter
Node
\family default
 objects.
\end_layout

\begin_deeper
\begin_layout Standard
The methods are
\end_layout

\begin_layout Enumerate

\family typewriter
get(key: INTEGER) : List
\family default
 // returns a 
\family typewriter
List
\end_layout

\begin_layout Enumerate

\family typewriter
set(key: INTEGER, data: List) : None 
\family default
// setting a key value pair in the 
\family typewriter
Dictionary
\family default
.
\end_layout

\end_deeper
\begin_layout Enumerate
The idea for the algorithm is as follows:
\end_layout

\begin_deeper
\begin_layout Itemize
We have a 
\family typewriter
List
\family default
, 
\family typewriter
visited
\family default
 to keep the nodes found.
 Set to empty initially.
\end_layout

\begin_layout Itemize
Call recursive function to lookup all the directly connected nodes from
 
\family typewriter
source
\family default
 and return 
\family typewriter
visited
\family default
 
\end_layout

\begin_deeper
\begin_layout Itemize
Base case, if 
\family typewriter
source
\family default
 is in 
\family typewriter
visited
\family default
 then return 
\family typewriter
visited
\family default
 
\end_layout

\begin_layout Itemize
Recursive step: 
\end_layout

\begin_deeper
\begin_layout Itemize
Add 
\family typewriter
source
\family default
 to 
\family typewriter
visited
\family default
 
\end_layout

\begin_layout Itemize
Lookup 
\family typewriter
source
\family default
 from graph for a 
\family typewriter
List
\family default
 of neighbour nodes.
 Call recusive function for each neighbour node as source 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
We will assume the following method to the List data structure introduced
 above:
\end_layout

\begin_layout Itemize

\family typewriter
inList(n: Object) : Boolean
\family default
 // returns 
\family typewriter
True
\family default
 if object 
\family typewriter
n
\family default
 is in the 
\family typewriter
List
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family typewriter
FUNCTION Helper(graph: DICTIONARY, source: INTEGER, visited: List) RETURNS
 List 
\end_layout

\begin_layout Plain Layout

\family typewriter
DECLARE neighbours: List
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

IF visited.inList(source) THEN 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

RETURN visited 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

ENDIF
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

visited.append(source) //1m 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

neighbours <- graph.get(source) //1m 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

node <- neighbours.getHead() 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

WHILE node <> None DO 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

visited <- Helper(graph, node.getID(), visited) //1m
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

node <- neighbours.getNext(node) 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

ENDWHILE
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

RETURN visited 
\end_layout

\begin_layout Plain Layout

\family typewriter
ENDFUNCTION
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout

\family typewriter
FUNCTION FindPath(graph: OBJECT, source: INTEGER) RETURNS List 
\end_layout

\begin_layout Plain Layout

\family typewriter
DECLARE visited: List 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

visited <- List() 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

Helper <- (graph, source, visited) 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

RETURN visited 
\end_layout

\begin_layout Plain Layout

\family typewriter
ENDFUNCTION 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
The idea for the algorithm is as follows:
\end_layout

\begin_deeper
\begin_layout Itemize
Iterate over the set of nodes in graph 
\end_layout

\begin_layout Itemize
Check if nodes visited is same size as the nodes in the graph 
\end_layout

\begin_layout Standard
We will assume the following method available on List and 
\family typewriter
DICTIONARY
\family default
 object:
\end_layout

\begin_layout Itemize

\family typewriter
size(): INTEGER
\family default
 // size of List
\end_layout

\begin_layout Itemize

\family typewriter
getKeys(): ARRAY [1:N] of INTEGERS
\family default
 // array of the keys in 
\family typewriter
DICTIONARY
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family typewriter
PROCEDURE Helper(graph: DICTIONARY) 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

nodes <- graph.getKeys() 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

FOR i <- 1 to LEN(nodes) //LEN returns size of array 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

paths <- FindPath(graph, nodes[i])
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

IF paths.size() = LEN(nodes) THEN //1m
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

OUTPUT( "Node", nodes[i] )
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

ENDIF
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

ENDFOR
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Given an input data , a hash function should uniformly distribute the input
 data across the range of addresses.
\end_layout

\begin_layout Enumerate
The address is fully determined by the data being hashed or given two identical
 input data the hash function must generate the same address.
\end_layout

\begin_layout Enumerate
Produce minimal collision 
\end_layout

\end_deeper
\begin_layout Enumerate
When the hash function generates a address in the hash table that is already
 occupied.
 In separate chaining: 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family typewriter
IF the address maps to a memory location that is not occupied THEN 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

Create a empty linked list in the memory location 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

Append the data value to the linked list 
\end_layout

\begin_layout Plain Layout

\family typewriter
ELSE 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

Append the data to the end of the linked list 
\end_layout

\begin_layout Plain Layout

\family typewriter
ENDIF 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
In linear probing, the data values that are map to the same address in the
 hash table will have the data stored in consecutive locations, input data
 that maps to these locations that are already occuied further increase
 the length of the consecutive locations, resulting in clustering of data
 in the hash table.
\end_layout

\begin_layout Enumerate
We have
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family typewriter
IF table[i] = NONE THEN 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

table[i] <- name //(i)
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

RETURN True 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

ELSE IF i = key THEN 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset


\begin_inset space \qquad{}
\end_inset

RETURN FALSE //(ii) 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

ELSE 
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space \qquad{}
\end_inset

step <- step + 1 //(iii) 
\end_layout

\begin_layout Plain Layout

\family typewriter
ENDIF 
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
iv.
\end_layout

\end_inset

Instead of using the next free memory location, this algorithm selects a
 new location that is twice the interval from the previous location.
\end_layout

\begin_deeper
\begin_layout Standard
This solves the clustering problem , as the data are more distributed in
 the hash table.
 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
v.
\end_layout

\end_inset

The probing does not search for all memory locations in the table.
 
\end_layout

\begin_deeper
\begin_layout Standard
Results in a lot of empty slots that are not used.
 
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
A set of rules that determine how the sender and receiver exchange data
\end_layout

\begin_layout Enumerate
Resolve domain names to IP addresses
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The logical name space (data) is centralised, there is only 1 global domain
 name space on the Internet.
 ie domain names are unique.
\end_layout

\begin_layout Itemize
The database storing the name space is decentralised via a hierarchical
 structure.
 Different partitions of the namespace are maintained by different authoritative
 DNS servers.
 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
http
\family default
: protocol 
\end_layout

\begin_layout Itemize

\family typewriter
nationaljc.moe.edu.sg
\family default
: domain name 
\end_layout

\begin_layout Itemize

\family typewriter
8088
\family default
: port number of listening socket 
\end_layout

\begin_layout Itemize

\family typewriter
/20SH07
\family default
: resource 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Domain name resolved to ip address 
\end_layout

\begin_layout Itemize
Browser connects to the remote server port 
\family typewriter
8088
\family default
 
\end_layout

\begin_layout Itemize
Sends a http request for 
\family typewriter
/20SH07 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Web browser client uses the HTTP protocol to send and receive html contents,
 which is converted from the raw email content by the email web application
 server.(Gmail) 
\end_layout

\begin_layout Itemize
Offline vs online access 
\end_layout

\begin_layout Itemize
Native device user interface vs web interface 
\end_layout

\begin_layout Itemize
Native email client uses the SMTP protocol to communicate with a email server
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Create a socket to connect to the web server ip address and port number
 (8088) 
\end_layout

\begin_layout Itemize
Generate a HTTP GET request message for the hidden page resource (/20SH07)
\end_layout

\begin_layout Itemize
Receive and decode the return HTML message content 
\end_layout

\begin_layout Itemize
Parse the HTML content to extract the parts that contains data 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The contents of the school's web site is protected by copyrights laws.
 (you aren't copyrighting a "website," but you can copyright the contents
 of that website) 
\end_layout

\begin_layout Itemize
By extracting data from the web site, you are re-using "original content"
 without permission and therefore is in violation of copyrights laws.
\end_layout

\begin_layout Itemize
The privacy of the people whose personal data you extract has been compromised.
 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Consent is not obtained from the staff / students 
\end_layout

\begin_layout Itemize
Purpose for the use of the data is different from the original intent.
 
\end_layout

\begin_layout Itemize
Data Protection is not inplace 
\end_layout

\begin_layout Itemize
Removal of contents once its purpose is no longer in need.
 
\end_layout

\end_deeper
\begin_layout Enumerate
A central authority should kept the information, access to information is
 granted and control by the central authority.
 Authentication and access control should be enforced.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Encoding is in utf-16 
\end_layout

\begin_layout Itemize
Web scraping program is using another encoding scheme by default 
\end_layout

\begin_layout Itemize
Terminal console used by the web scraping program does not have the fonts
 for the character encoding.
 
\end_layout

\end_deeper
\end_deeper
\end_body
\end_document
